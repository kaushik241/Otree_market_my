from .models import Group as MarketGroup
from .exchange.base import OrderStatusEnum

import json
import datetime
import csv


class BaseMarketOutputGenerator():
    '''this class allows the creation of arbitrary output files for a markets session.

    one of these objects is created every time a download is triggered for a session. the output generator is provided a session object
    (in self.session) which can be accessed to generate filenames and output data.

    to create a new output format, create a new file in your app called 'output.py', subclass this class (or one of the other
    base output generators) and fill out the methods appropriately. add your subclass to a list called 'output_generators' at the
    bottom of output.py and it'll be included as a download option on the data export screen.

    note that if you specify 'output_generators' in your output.py, the default JSON output generator will not be included. you can add
    it back by importing DefaultJSONMarketOutputGenerator from this file and including it in your list.
    '''

    download_link_text = 'get output'
    '''the text that will be shown on the download link for this output format
    '''

    def __init__(self, session):
        self.session = session

    def get_mime_type(self):
        '''return an appropriate mime type for this download.

        this should generally match with the file extension you give with the filename
        '''
        return 'text/plain'
    
    def get_filename(self):
        '''return an appropriate filename for this download

        it should probably include the session code and the current date. the file extension should
        also reflect the type of data being returned.
        '''
        raise NotImplementedError()

    def write_output(self, response):
        '''this method writes the actual output data

        the response parameter is a Django HTTPResponse object. importantly it's a file-like object,
        so it can be written to in the exact same way you would write to a file opened with open().
        you can think of the response object as a file object representing the final downloaded output file.
        '''
        raise NotImplementedError()


class BaseCSVMarketOutputGenerator(BaseMarketOutputGenerator):
    '''this class is a base output generator which simplifies the creation of CSV output files

    to use it, simply subclass it in output.py and fill out 'get_header' and 'get_group_output', then add it to output_generators
    as described above
    '''

    download_link_text = 'get csv'

    def get_mime_type(self):
        return 'text/csv'

    def get_filename(self):
        return '{} Market Data - session {} (accessed {}).csv'.format(
            self.session.config['display_name'],
            self.session.code,
            datetime.date.today().isoformat()
        )

    def write_output(self, response):
        writer = csv.writer(response)
        writer.writerow(self.get_header())
        for subsession in self.session.get_subsessions():
            for group in subsession.get_groups():
                if not isinstance(group, MarketGroup):
                    continue
                writer.writerows(self.get_group_output(group))

    def get_header(self):
        '''this method should return a list of strings which will form the csv's header
        '''
        raise NotImplementedError()
    
    def get_group_output(self, group):
        '''this method should be a generator which yields one list of values for each row in the csv

        it's called once for each group object in the selected session. that group object is passed in as the 'group'
        parameter.
        '''
        raise NotImplementedError()


class BaseJSONMarketOutputGenerator(BaseMarketOutputGenerator):
    '''this class is a base output generator which simplifies the creation of JSON output files

    to use it, simply subclass it in output.py and fill out 'get_group_data', then add it to output_generators
    as described above. the response generated by this generator is a JSON list of objects representing the output for
    each group.
    '''

    download_link_text = 'get json'

    def get_mime_type(self):
        return 'application/json'

    def get_filename(self):
        return '{} Market Data - session {} (accessed {}).json'.format(
            self.session.config['display_name'],
            self.session.code,
            datetime.date.today().isoformat()
        )

    def write_output(self, response):
        group_data = []
        for subsession in self.session.get_subsessions():
            for group in subsession.get_groups():
                if not isinstance(group, MarketGroup):
                    continue
                data = self.get_group_data(group)
                if data is not None:
                    group_data.append(data)

        json.dump(group_data, response)

    def get_group_data(self, group):
        '''this method should return a JSON serializable object representing the output for a single group.

        this method can also return None if you'd like to exclude a group from the output list
        '''
        raise NotImplementedError()


class DefaultJSONMarketOutputGenerator(BaseJSONMarketOutputGenerator):
    '''this class is the default output generator

    it returns dicts with the round number and id for each group, along with lists of all the orders
    and trades which were created during that group's trading period. all order and trade timestamps
    are in seconds relative to the start of the round.
    '''

    def order_to_output_dict(self, order, start_time):
        return {
            'time_entered': (order.timestamp - start_time).total_seconds(),
            'price': order.price,
            'volume': order.volume,
            'is_bid': order.is_bid,
            'pcode': order.pcode,
            'traded_volume': order.traded_volume,
            'id': order.id,
            'status': OrderStatusEnum(order.status).name,
            'time_inactive': (order.time_inactive - start_time).total_seconds() if order.time_inactive else None,
        }
    
    def trade_to_output_dict(self, trade, start_time):
        return {
            'timestamp': (trade.timestamp - start_time).total_seconds(),
            'taking_order_id': trade.taking_order.id,
            'making_order_ids': [ o.id for o in trade.making_orders.all() ],
        }
    
    def get_group_data(self, group):
        start_time = group.get_start_time()

        exchange_data = []
        exchange_query = group.exchanges.all().prefetch_related('orders', 'trades')
        for exchange in exchange_query:
            orders = [self.order_to_output_dict(e, start_time) for e in exchange.orders.all()]
            trades = [self.trade_to_output_dict(e, start_time) for e in exchange.trades.all()]
            exchange_data.append({
                'asset_name': exchange.asset_name,
                'orders': orders,
                'trades': trades,
            })
        if not exchange_data:
            return None
        return {
            'round_number': group.round_number,
            'id_in_subsession': group.id_in_subsession,
            'exchange_data': exchange_data,
        }
